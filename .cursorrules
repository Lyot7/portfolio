# Portfolio Project - Cursor Rules

## Project Overview
This is a modern freelance website built with clean architecture principles and SOLID design patterns.

## Technology Stack
- **Frontend**: Next.js 15+ with TypeScript
- **Styling**: Tailwind CSS
- **Animations**: Framer Motion + React Bits (for pre-made beautiful components)
- **Icons**: Lucide React
- **UI Components**: React Bits (creative landing components, skeletons, loaders)
- **Internationalization**: next-intl for automatic translation
- **Deployment**: Vercel
- **Package Manager**: pnpm (preferred for performance)

## Architecture Principles

### SOLID Principles Implementation
- **Single Responsibility**: Each component/hook/utility has one clear purpose
- **Open/Closed**: Components are extensible without modification
- **Liskov Substitution**: Components can be replaced with compatible alternatives
- **Interface Segregation**: Small, focused interfaces over large ones
- **Dependency Inversion**: High-level modules don't depend on low-level modules

### Clean Architecture
- Separate concerns into distinct layers
- Follow the dependency rule (dependencies point inward)
- Keep business logic independent of frameworks
- Use dependency injection where appropriate
- Implement composition over inheritance

### Component Composition Strategy
- **Base Components**: Reusable, configurable building blocks
- **Specialized Components**: Domain-specific components using composition
- **Layout Components**: Structural components for page organization
- **Section Components**: Content-specific components for different page sections

## Folder Structure
```
src/
â”œâ”€â”€ app/                    # Next.js app router with i18n
â”‚   â”œâ”€â”€ [locale]/          # Internationalization routes
â”‚   â”‚   â”œâ”€â”€ page.tsx       # Accueil (Home)
â”‚   â”‚   â”œâ”€â”€ projets/       # Projects page
â”‚   â”‚   â”œâ”€â”€ parcours/      # Journey/Experience page
â”‚   â”‚   â””â”€â”€ contact/       # Contact page
â”‚   â”œâ”€â”€ globals.css        # Global styles
â”‚   â””â”€â”€ layout.tsx         # Root layout
â”œâ”€â”€ components/             # Reusable UI components
â”‚   â”œâ”€â”€ ui/                # Base UI components
â”‚   â”‚   â”œâ”€â”€ buttons/       # Button components (Button, AnimatedButton, etc.)
â”‚   â”‚   â”œâ”€â”€ forms/         # Form components (FormField, Input, etc.)
â”‚   â”‚   â””â”€â”€ index.ts       # Main UI exports
â”‚   â”œâ”€â”€ layout/            # Layout components (Header, Navigation, etc.)
â”‚   â”œâ”€â”€ sections/          # Page sections (HeroSection, etc.)
â”‚   â”œâ”€â”€ skeletons/         # Loading skeletons (React Bits)
â”‚   â””â”€â”€ loaders/           # Loading components (React Bits)
â”œâ”€â”€ hooks/                 # Custom React hooks
â”‚   â”œâ”€â”€ useForm.ts         # Form management hook
â”‚   â”œâ”€â”€ useMediaQuery.ts   # Media query hook
â”‚   â”œâ”€â”€ useScrollDirection.ts # Scroll direction hook
â”‚   â””â”€â”€ useTranslations.ts # Translations hook
â”œâ”€â”€ lib/                   # Utility functions and configurations
â”‚   â”œâ”€â”€ validation.ts      # Validation utilities
â”‚   â”œâ”€â”€ utils.ts           # General utilities
â”‚   â”œâ”€â”€ languages.ts       # Language utilities
â”‚   â””â”€â”€ index.ts           # Main lib exports
â”œâ”€â”€ contexts/              # React contexts
â”‚   â”œâ”€â”€ ThemeContext.tsx   # Theme management
â”‚   â””â”€â”€ LanguageContext.tsx # Language management
â”œâ”€â”€ types/                 # TypeScript type definitions
â”‚   â”œâ”€â”€ theme.ts           # Theme types
â”‚   â””â”€â”€ index.ts           # Main type exports
â”œâ”€â”€ data/                  # Static data and constants
â”‚   â””â”€â”€ constants.ts       # Application constants
â”œâ”€â”€ locales/               # Translation files (fr, en, etc.)
â””â”€â”€ assets/                # Images, icons, and other static assets
```

## Component Guidelines

### SOLID Component Design
- **Single Responsibility**: One component = one purpose
- **Open/Closed**: Extend with props, not by modifying
- **Composition**: Use composition over inheritance
- **Interface Segregation**: Small, focused prop interfaces
- **Dependency Inversion**: Depend on abstractions, not concretions

### Component Architecture
- **Base Components**: Button, Input, FormField (highly reusable)
- **Specialized Components**: SubmitButton, ActionButton (composed from base)
- **Layout Components**: Header, Navigation, GlobalLayout (structural)
- **Section Components**: HeroSection, ContactForm (content-specific)

### Component Composition Pattern
```typescript
// Base component
<Button variant="primary" size="lg">Click me</Button>

// Specialized component using composition
<SubmitButton isLoading={true}>Submit</SubmitButton>

// Layout component
<Header>
  <Navigation items={navItems} />
</Header>
```

### File Naming Conventions
- **Components**: PascalCase (e.g., `HeroSection.tsx`)
- **Hooks**: camelCase with "use" prefix (e.g., `useForm.ts`)
- **Utilities**: camelCase (e.g., `validation.ts`)
- **Types**: PascalCase (e.g., `ButtonProps.ts`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `APP_CONFIG`)

## Code Quality Standards

### TypeScript
- Enable strict mode
- Use proper type annotations
- Avoid `any` type unless absolutely necessary
- Prefer interfaces over types for object shapes
- Use utility types when appropriate (Partial, Pick, Omit, etc.)
- Export types from dedicated type files

### React Best Practices
- Use functional components with TypeScript
- Implement proper prop types and interfaces
- Use React.memo() for performance optimization when needed
- Implement proper error boundaries
- Use proper key props in lists
- Avoid unnecessary re-renders
- Use useCallback and useMemo judiciously

### SOLID Implementation Examples

#### Single Responsibility
```typescript
// âœ… Good: One component, one purpose
export function SubmitButton({ isLoading, children, ...props }) {
  return <Button type="submit" variant="primary" isLoading={isLoading} {...props}>{children}</Button>;
}

// âŒ Bad: Multiple responsibilities
export function FormWithValidationAndSubmission() { /* Too many things */ }
```

#### Open/Closed Principle
```typescript
// âœ… Good: Extensible through props
export function Button({ variant, size, children, ...props }) {
  const variants = { primary: 'bg-primary', secondary: 'bg-secondary' };
  return <button className={variants[variant]} {...props}>{children}</button>;
}

// âŒ Bad: Hard to extend
export function Button() {
  return <button className="bg-primary text-white">Click me</button>;
}
```

#### Interface Segregation
```typescript
// âœ… Good: Small, focused interfaces
export interface ButtonProps {
  variant?: 'primary' | 'secondary';
  size?: 'sm' | 'md' | 'lg';
  children: ReactNode;
}

// âŒ Bad: Large, unfocused interface
export interface ComponentProps {
  // 50+ properties for different use cases
}
```

### Styling Guidelines
- Use Tailwind CSS utility classes
- Create custom components for repeated patterns
- Follow mobile-first responsive design
- Maintain consistent spacing using Tailwind's scale
- Use CSS variables for theme customization
- Leverage CSS-in-JS for dynamic styles when needed

### Performance
- Optimize images (use Next.js Image component)
- Implement lazy loading for below-the-fold content
- Minimize bundle size
- Use proper caching strategies
- Implement proper SEO practices
- Use React Bits skeletons for instant loading feedback
- Implement page-level loading states and transitions
- Leverage Next.js static generation for better performance
- Use React.Suspense with React Bits loaders for code splitting

## Code Organization Rules

### No Duplication (DRY Principle)
- Extract common logic into utilities or hooks
- Create reusable components for repeated UI patterns
- Use constants for repeated values
- Implement shared types for common data structures
- Centralize configuration in constants files

### Import Organization
```typescript
// 1. React and Next.js imports
import React from 'react'
import { NextPage } from 'next'

// 2. Third-party libraries
import { motion } from 'framer-motion'
import { ChevronDown } from 'lucide-react'

// 3. Internal imports (absolute paths preferred)
import { Button } from '@/components/ui/buttons'
import { useForm } from '@/hooks/useForm'
import { ButtonProps } from '@/types/Button'

// 4. Relative imports (only for closely related files)
import './styles.css'
```

### Component Export Strategy
```typescript
// âœ… Good: Named exports for components
export { Button } from './Button';
export { SubmitButton } from './SubmitButton';

// âœ… Good: Type exports
export type { ButtonProps } from './Button';

// âŒ Bad: Default exports for components
export default Button;
```

### Error Handling
- Implement proper error boundaries
- Use try-catch blocks for async operations
- Provide meaningful error messages
- Log errors appropriately for debugging
- Use validation utilities for form handling

## Git Workflow
- Use conventional commit messages
- Create feature branches for development
- Write descriptive commit messages
- Keep commits atomic and focused
- Follow SOLID principles in code changes

## Accessibility (a11y)
- Use semantic HTML elements
- Implement proper ARIA labels
- Ensure keyboard navigation works
- Maintain proper color contrast ratios
- Test with screen readers
- Follow WCAG guidelines

## Security
- Sanitize user inputs
- Use environment variables for sensitive data
- Implement proper CSP headers
- Follow OWASP guidelines
- Validate all form inputs

## Testing Strategy
- Write unit tests for utilities and hooks
- Implement integration tests for critical flows
- Use React Testing Library for component tests
- Maintain good test coverage
- Test SOLID principles implementation

## Development Workflow
1. Plan the feature/component architecture following SOLID principles
2. Create types and interfaces first
3. Implement base components with single responsibility
4. Create specialized components using composition
5. Add proper styling with Tailwind
6. Test functionality and responsiveness
7. Optimize for performance
8. Ensure SOLID compliance

## Documentation
- Document component interfaces and props
- Document hook usage and return values
- Document utility functions and their purposes
- Document SOLID implementation decisions
- Document any custom configurations

## Prohibited Practices
- No inline styles (use Tailwind classes)
- No console.log in production code
- No unused imports or variables
- No magic numbers (use named constants)
- No deep nesting (max 3-4 levels)
- No large components (split into smaller ones)
- No violation of SOLID principles
- No component with multiple responsibilities
- No hardcoded values (use constants)

## macOS Development Notes
- Use absolute paths consistently
- Configure proper file permissions
- Use Homebrew for package management
- Set up proper environment variables
- Configure Git with proper credentials

## Performance Targets
- First Contentful Paint: < 1.5s
- Largest Contentful Paint: < 2.5s
- Cumulative Layout Shift: < 0.1
- Time to Interactive: < 3s
- Bundle size: < 250KB gzipped

## Portfolio-Specific Requirements

### Pages Structure
1. **Accueil (Home)** - Creative landing page with React Bits hero components
2. **Projets (Projects)** - Showcase portfolio projects with interactive elements
3. **Parcours (Journey)** - Professional experience and education timeline
4. **Contact** - Contact form with React Bits form components

### Creative Landing Page Guidelines
- Use React Bits hero sections and creative components
- Implement eye-catching animations and micro-interactions
- Ensure mobile-first responsive design
- Include compelling call-to-action elements
- Use React Bits gradient backgrounds and visual effects

### User Experience (UX) Priorities
- **Loading States**: Every page transition must have React Bits loaders
- **Skeleton Screens**: Use React Bits skeletons for content loading
- **Smooth Navigation**: Implement seamless page transitions
- **Progressive Loading**: Load critical content first, then enhance
- **Error Boundaries**: Graceful error handling with React Bits error components

### Internationalization (i18n) Requirements
- **Auto-detection**: Detect user's country/language automatically
- **Supported Languages**: French (primary) and English (secondary)
- **Fallback**: Default to French if detection fails
- **SEO**: Proper hreflang tags for international SEO
- **URL Structure**: /fr/ and /en/ routes for all pages
- **Translation Keys**: Organized by page and component

### React Bits Integration Strategy
- **Components**: Leverage pre-built React Bits components for speed
- **Animations**: Use React Bits animations over custom Framer Motion when possible
- **Consistency**: Maintain visual consistency with React Bits design system
- **Customization**: Extend React Bits components with Tailwind when needed
- **Performance**: Prefer React Bits optimized components for better performance

### Navigation Structure
```
Navigation:
â”œâ”€â”€ Accueil (/)
â”œâ”€â”€ Projets (/projets)
â”œâ”€â”€ Parcours (/parcours)
â””â”€â”€ Contact (/contact)

Language Switching:
â”œâ”€â”€ ğŸ‡«ğŸ‡· FranÃ§ais
â””â”€â”€ ğŸ‡¬ğŸ‡§ English
```

### Content Loading Strategy
1. **Critical Path**: Load navigation and hero section first
2. **Progressive Enhancement**: Add animations and interactive elements
3. **Below Fold**: Lazy load non-critical content with React Bits loaders
4. **Images**: Use Next.js Image with React Bits placeholder components
5. **Fonts**: Preload critical fonts, fallback gracefully

## SOLID Implementation Checklist

### Single Responsibility Principle
- [ ] Each component has one clear purpose
- [ ] Each hook manages one specific concern
- [ ] Each utility function does one thing
- [ ] Each type represents one concept

### Open/Closed Principle
- [ ] Components are extensible through props
- [ ] Hooks accept configuration options
- [ ] Utilities are configurable
- [ ] Types are extensible

### Liskov Substitution Principle
- [ ] Components can be replaced with compatible alternatives
- [ ] Hooks can be swapped for similar functionality
- [ ] Utilities can be replaced with equivalent functions

### Interface Segregation Principle
- [ ] Prop interfaces are small and focused
- [ ] Hook return types are minimal
- [ ] Utility function signatures are simple
- [ ] Type definitions are specific

### Dependency Inversion Principle
- [ ] High-level components don't depend on low-level ones
- [ ] Components depend on abstractions (interfaces)
- [ ] Hooks are framework-agnostic
- [ ] Utilities are independent of implementation details

Remember: Always check for existing implementations before creating new ones. Maintain consistency across the codebase and follow these established SOLID patterns. Prioritize user experience with React Bits components for a polished, professional portfolio while maintaining clean, maintainable code architecture.
